<!DOCTYPE html>
<html lang="en">
  <head>
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><circle cx='32' cy='32' r='28' fill='%23ff6a00'/><text x='32' y='42' font-size='32' text-anchor='middle' fill='white' font-family='Orbitron,sans-serif'>D</text></svg>"
    />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DoubleShines Task Tracker</title>
    <link rel="stylesheet" href="./assets/tailwind.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --glow-color: #ff6a00;
        --item-height: 60px;
      }
      body {
        font-family: 'Poppins', sans-serif;
        background-color: #111827;
        color: #f3f4f6;
        /* Allow vertical scroll for the whole page; keep horizontal hidden to avoid confetti/animation scrollbars */
        overflow-x: hidden;
        overflow-y: auto;
      }
      .title-font {
        font-family: 'Orbitron', sans-serif;
      }
      .neon-glow {
        box-shadow: 0 0 5px var(--glow-color), 0 0 10px var(--glow-color);
      }
      .neon-text {
        text-shadow: 0 0 5px var(--glow-color), 0 0 10px var(--glow-color);
      }
      .ticker-viewport {
        height: calc(var(--item-height) * 5);
        width: 100%;
        overflow: hidden;
        position: relative;
        border-radius: 12px;
        border: 1px solid #374151;
        background-color: rgba(0, 0, 0, 0.1);
      }
      .ticker-reel {
        width: 100%;
        height: 100%;
        position: relative;
      }
      .ticker-item {
        height: var(--item-height);
        position: absolute;
        left: 0;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        font-weight: 600;
        color: white;
        padding: 0 20px;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
      }
      .ticker-viewport::before,
      .ticker-viewport::after {
        content: '';
        position: absolute;
        left: 0;
        width: 100%;
        height: calc(var(--item-height) * 2);
        z-index: 2;
        pointer-events: none;
      }
      .ticker-viewport::before {
        top: 0;
        background: linear-gradient(to bottom, #111827, transparent);
      }
      .ticker-viewport::after {
        bottom: 0;
        background: linear-gradient(to top, #111827, transparent);
      }
      .pointer-line {
        position: absolute;
        top: 50%;
        left: 0;
        width: 100%;
        height: var(--item-height);
        transform: translateY(-50%);
        border-top: 2px solid var(--glow-color);
        border-bottom: 2px solid var(--glow-color);
        box-shadow: 0 0 15px var(--glow-color);
        z-index: 1;
        opacity: 0.7;
      }
      .modal {
        transition: opacity 0.25s ease;
      }
      .modal-content {
        transition: transform 0.25s ease;
      }
      .task-item:hover .remove-btn {
        opacity: 1;
        transform: translateX(0);
      }
      .remove-btn {
        opacity: 0;
        transform: translateX(10px);
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
      }
      input[type='range'] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 10px;
        background: #374151;
        border-radius: 5px;
        outline: none;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      input[type='range']:hover {
        opacity: 1;
      }
      input[type='range']::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        background: var(--glow-color);
        border-radius: 50%;
        cursor: pointer;
      }
      input[type='range']::-moz-range-thumb {
        width: 25px;
        height: 25px;
        background: var(--glow-color);
        border-radius: 50%;
        cursor: pointer;
      }
      .transition-all-layout {
        transition: all 0.5s ease-in-out;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        filter: grayscale(50%);
      }
      nav,
      nav * {
        pointer-events: none !important;
      }
      #toggleManageBtn,
      #taskViewerBtn {
        pointer-events: auto !important;
      }

      .task-grid {
        display: grid;
        gap: 0.5rem;
        width: 100%;
        height: 100%;
      }
      .task-grid-item {
        background-color: #374151;
        border-radius: 8px;
        color: #f3f4f6;
        transition: background-color 0.3s ease, transform 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 4px;
        font-size: 12px;
        overflow: hidden;
        word-break: break-word;
      }
      .task-grid-item:hover {
        transform: scale(1.05);
        z-index: 10;
      }
      .task-grid-item.completed {
        background-color: #166534;
        color: #d1fae5;
      }

      .confetti-particle {
        position: fixed;
        top: 105vh;
        left: var(--x-start);
        pointer-events: none;
        font-size: var(--size);
        opacity: 0;
        animation: confetti-arc forwards;
        animation-duration: var(--duration);
        animation-timing-function: cubic-bezier(0.25, 1, 0.5, 1);
        animation-delay: var(--delay);
      }
      @keyframes confetti-arc {
        0% {
          transform: translateY(0) translateX(0) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translateY(-120vh) translateX(var(--x-end)) rotate(720deg);
          opacity: 0;
        }
      }

      /* Styles for new viewer control buttons */
      .viewer-btn {
        padding: 0.5rem 1rem;
        background-color: #4b5563;
        color: white;
        transition: all 0.2s ease-in-out;
        border: 1px solid #374151;
        font-weight: 600;
      }
      .viewer-btn:hover {
        background-color: #374151;
      }
      .viewer-btn.active {
        background-color: var(--glow-color);
        color: #111827;
        box-shadow: 0 0 8px var(--glow-color);
        border-color: var(--glow-color);
        transform: scale(1.05);
      }
      #filterControls button:first-child,
      #sortControls button:first-child {
        border-top-left-radius: 0.5rem;
        border-bottom-left-radius: 0.5rem;
      }
      #filterControls button:last-child,
      #sortControls button:last-child {
        border-top-right-radius: 0.5rem;
        border-bottom-right-radius: 0.5rem;
      }
    </style>
  </head>
  <body class="bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4 pt-24">
    <nav class="fixed top-0 left-0 w-full z-50">
      <div class="flex items-center justify-between p-2">
        <img src="DSSIT.png" alt="DoubleShines Logo" />
        <div class="flex space-x-2">
          <button
            id="taskViewerBtn"
            class="bg-gray-700 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition-colors"
          >
            Task Viewer
          </button>
          <button
            id="toggleManageBtn"
            class="bg-gray-700 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition-colors"
          >
            Manage Tasks
          </button>
        </div>
      </div>
    </nav>

    <div
      id="currentTaskContainer"
      class="w-full max-w-6xl mx-auto mb-8 p-6 rounded-2xl border border-gray-700 bg-gray-800/50 backdrop-blur-sm hidden"
    >
      <div class="text-center mb-4">
        <h2 id="taskStatusHeader" class="title-font text-2xl font-bold text-white">Current Task</h2>
        <p id="completionStats" class="text-xl font-semibold text-gray-200"></p>
      </div>
      <p
        id="currentTaskText"
        class="title-font text-4xl font-bold text-white neon-text text-center mb-6"
      ></p>
      <div id="currentTaskActions" class="flex justify-center space-x-4">
        <button
          id="currentTaskSkipBtn"
          class="bg-gray-600 text-white font-bold py-2 px-6 rounded-full hover:bg-gray-700 transition-colors"
        >
          Skip
        </button>
        <button
          id="currentTaskCompleteBtn"
          class="bg-[var(--glow-color)] text-gray-900 font-bold py-2 px-6 rounded-full hover:bg-opacity-80 transition-colors"
        >
          Completed
        </button>
      </div>
    </div>

    <div
      id="app-container"
      class="w-full max-w-[80vw] mx-auto flex flex-col lg:flex-row items-start justify-center gap-8 lg:gap-16 transition-all-layout"
    >
      <div
        id="spinnerContainer"
        class="flex flex-col items-center justify-center gap-6 w-full lg:w-full transition-all-layout"
      >
        <h1 class="title-font text-4xl md:text-5xl font-bold text-white neon-text text-center">
          DoubleShines Task Tracker
        </h1>
        <div class="ticker-viewport">
          <div class="pointer-line"></div>
          <div id="tickerReel" class="ticker-reel"></div>
        </div>
        <button
          id="spinBtn"
          class="title-font bg-gray-800 text-white font-bold py-4 px-10 rounded-full text-2xl border-2 border-[var(--glow-color)] transition-all duration-300 ease-in-out hover:bg-[var(--glow-color)] hover:text-gray-900 hover:scale-105 active:scale-95 neon-glow"
        >
          SPIN
        </button>
      </div>

      <div
        id="manageTasksPanel"
        class="w-full lg:w-1/3 bg-gray-800/50 backdrop-blur-sm p-6 rounded-2xl border border-gray-700 transition-all-layout hidden max-h-[80vh] overflow-y-auto"
      >
        <h2 class="text-2xl font-bold mb-4 border-b border-gray-600 pb-2">Manage Tasks</h2>
        <div class="mb-4 p-3 rounded-lg border border-gray-700 bg-gray-900/60">
          <div class="flex items-center justify-between">
            <h3 class="text-lg font-semibold">Roll Odds</h3>
            <div id="rollOddsInfo" class="text-right leading-5 text-sm"></div>
          </div>
        </div>
        <div class="flex mb-4">
          <input
            type="text"
            id="taskInput"
            placeholder="Enter a new task..."
            class="flex-grow bg-gray-900 border border-gray-600 rounded-l-lg p-3 focus:outline-none focus:ring-2 focus:ring-[var(--glow-color)] focus:border-transparent transition-all"
          />
          <button
            id="addTaskBtn"
            class="bg-[var(--glow-color)] text-gray-900 font-bold p-3 rounded-r-lg hover:bg-opacity-80 transition-colors"
          >
            +
          </button>
        </div>

        <input
          type="text"
          id="searchInput"
          placeholder="Search tasks..."
          class="w-full bg-gray-900 border border-gray-600 rounded-lg p-3 mb-4 focus:outline-none focus:ring-2 focus:ring-[var(--glow-color)] focus:border-transparent transition-all"
        />

        <div class="mb-4">
          <label for="spinDuration" class="block text-sm font-medium text-gray-300 mb-2"
            >Spin Duration: <span id="spinDurationValue">20</span> seconds</label
          >
          <input type="range" id="spinDuration" min="5" max="30" value="20" step="1" />
        </div>

        <div class="flex space-x-2 mb-4">
          <button
            id="shuffleBtn"
            class="w-1/2 bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors"
          >
            Shuffle
          </button>
          <button
            id="sortBtn"
            class="w-1/2 bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition-colors"
          >
            Sort A-Z
          </button>
        </div>
        <div id="taskList" class="space-y-2 max-h-[350px] overflow-y-auto pr-2"></div>

        <h3 class="text-xl font-bold mt-6 mb-2 border-t border-gray-600 pt-4">Completed Tasks</h3>
        <div
          id="completedTaskList"
          class="space-y-2 max-h-[200px] overflow-y-auto pr-2 text-gray-400"
        ></div>

        <div class="mt-6 border-t border-gray-600 pt-4">
          <h3 class="text-xl font-bold mb-3">Danger Zone</h3>
          <button
            id="resetAllBtn"
            class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition-colors mb-4"
            title="Reset all data and restore defaults"
          >
            Reset All (Are you sure?)
          </button>
        </div>
      </div>
    </div>

    <div
      id="winnerModal"
      class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 opacity-0 pointer-events-none"
    >
      <div
        id="modalContent"
        class="modal-content bg-gray-800 rounded-2xl p-8 text-center border-2 border-[var(--glow-color)] neon-glow transform scale-95"
      >
        <h2 class="text-xl font-light text-white mb-2">The chosen task is...</h2>
        <p id="winnerText" class="title-font text-5xl font-bold text-white neon-text mb-8"></p>
        <div class="flex justify-center space-x-4">
          <button
            id="modalOkayBtn"
            class="bg-[var(--glow-color)] text-gray-900 font-bold py-2 px-6 rounded-full hover:bg-opacity-80 transition-colors"
          >
            Okay
          </button>
        </div>
      </div>
    </div>

    <!-- Reset Confirmation Modal -->
    <div
      id="resetConfirmModal"
      class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-[60] opacity-0 pointer-events-none"
    >
      <div
        class="modal-content bg-gray-800 rounded-2xl p-8 text-center border-2 border-red-500 transform scale-95"
      >
        <h2 class="text-2xl font-bold text-white mb-3">Reset all data?</h2>
        <p class="text-gray-300 mb-6">
          This will clear your current pool, current task, and completed list, and restore the
          starting defaults. This action cannot be undone.
        </p>
        <div class="flex justify-center gap-4">
          <button
            id="resetConfirmNoBtn"
            class="bg-gray-600 text-white font-bold py-2 px-6 rounded-full hover:bg-gray-500 transition-colors"
          >
            Cancel
          </button>
          <button
            id="resetConfirmYesBtn"
            class="bg-red-600 text-white font-bold py-2 px-6 rounded-full hover:bg-red-700 transition-colors"
          >
            Yes, Reset
          </button>
        </div>
      </div>
    </div>

    <div
      id="taskViewerModal"
      class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-[60] opacity-0 pointer-events-none transition-opacity duration-300"
    >
      <div
        class="bg-gray-900/80 backdrop-blur-md w-[95vw] h-[95vh] rounded-2xl p-6 border border-gray-700 flex flex-col"
      >
        <div class="flex justify-between items-center mb-4 flex-shrink-0">
          <h2 class="text-3xl font-bold title-font text-white neon-text">Task Completion Viewer</h2>
          <button
            id="closeViewerBtn"
            class="text-3xl text-gray-400 hover:text-white transition-colors"
          >
            &times;
          </button>
        </div>

        <div
          class="flex flex-wrap gap-4 items-center justify-center mb-4 p-2 bg-gray-800/50 rounded-lg flex-shrink-0"
        >
          <div class="flex items-center gap-2">
            <span class="font-bold text-gray-300">Filter:</span>
            <div id="filterControls" class="inline-flex rounded-md shadow-sm" role="group">
              <button type="button" data-filter="all" class="viewer-btn">All</button>
              <button type="button" data-filter="completed" class="viewer-btn">Completed</button>
              <button type="button" data-filter="incomplete" class="viewer-btn">Incomplete</button>
            </div>
          </div>
          <div class="flex items-center gap-2">
            <span class="font-bold text-gray-300">Sort:</span>
            <div id="sortControls" class="inline-flex rounded-md shadow-sm" role="group">
              <button type="button" data-sort="az" class="viewer-btn">A-Z</button>
              <button type="button" data-sort="random" class="viewer-btn">Shuffle</button>
            </div>
          </div>
        </div>

        <div id="taskGrid" class="task-grid flex-grow min-h-0"></div>
      </div>
    </div>

    <footer
      style="
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        padding: 10px;
        background-color: rgba(17, 24, 39, 0.8);
        color: white;
        z-index: 100;
      "
    >
      <div class="w-full px-3 grid grid-cols-1 md:grid-cols-3 items-center gap-2 text-sm">
        <div class="text-left">
          <p>Made by Gecko | Version 1.9.3 pl | ¬© 2025</p>
        </div>
        <div class="text-center">
          <p class="text-gray-200">
            If you enjoy this site, your support helps keep it alive and enables more tools in the
            future - Thank You!
          </p>
        </div>
        <div class="text-right">
          <a
            href="https://www.buymeacoffee.com/themrgecko"
            target="_blank"
            rel="noopener noreferrer"
            aria-label="Buy me a coffee"
            class="inline-block bg-yellow-400 hover:bg-yellow-300 text-gray-900 font-semibold px-4 py-2 rounded shadow"
          >
            Buy me a coffee
          </a>
        </div>
      </div>
    </footer>

    <script>
      // --- Default Task Lists ---
      const defaultEasyTasks = [
        'easy1',
        'easy2',
        'easy3',
        'easy4',
        'easy5',
        'easy6',
        'easy7',
        'easy8',
        'easy9',
        'easy10',
        // EASY tasks go here
      ];
      const defaultMediumTasks = [
        'medium1',
        'medium2',
        'medium3',
        'medium4',
        'medium5',
        'medium6',
        'medium7',
        'medium8',
        'medium9',
        'medium10',
        'medium11',
        'medium12',
        'medium13',
        'medium14',
        // MEDIUM tasks go here
      ];
      const defaultHardTasks = [
        'hard1',
        'hard2',
        'hard3',
        'hard4',
        'hard5',
        'hard6',
        'hard7',
        'hard8',
        'hard9',
        'hard10',
        'hard11',
        'hard12',
        'hard13',
        'hard14',
        'hard15',
        // HARD tasks go here
      ];
      const defaultMasterTasks = [
        'master1',
        'master2',
        'master3',
        'master4',
        'master5',
        'master6',
        'master7',
        'master8',
        'master9',
        // MASTER tasks go here
      ];
      const defaultGrandMasterTasks = [
        'grandmaster1',
        'grandmaster2',
        'grandmaster3',
        'grandmaster4',
        'grandmaster5',
        'grandmaster6',
        'grandmaster7',
        'grandmaster8',
        'grandmaster9',
        'grandmaster10',
        // GRAND-MASTER tasks go here
      ];

      // DOM Elements
      const tickerReel = document.getElementById('tickerReel'),
        spinBtn = document.getElementById('spinBtn'),
        taskInput = document.getElementById('taskInput'),
        addTaskBtn = document.getElementById('addTaskBtn'),
        shuffleBtn = document.getElementById('shuffleBtn'),
        sortBtn = document.getElementById('sortBtn'),
        spinDurationSlider = document.getElementById('spinDuration'),
        spinDurationValue = document.getElementById('spinDurationValue'),
        taskList = document.getElementById('taskList'),
        winnerModal = document.getElementById('winnerModal'),
        modalContent = document.getElementById('modalContent'),
        winnerText = document.getElementById('winnerText'),
        modalOkayBtn = document.getElementById('modalOkayBtn'),
        toggleManageBtn = document.getElementById('toggleManageBtn'),
        manageTasksPanel = document.getElementById('manageTasksPanel'),
        spinnerContainer = document.getElementById('spinnerContainer'),
        appContainer = document.getElementById('app-container'),
        currentTaskContainer = document.getElementById('currentTaskContainer'),
        currentTaskText = document.getElementById('currentTaskText'),
        currentTaskSkipBtn = document.getElementById('currentTaskSkipBtn'),
        currentTaskCompleteBtn = document.getElementById('currentTaskCompleteBtn'),
        searchInput = document.getElementById('searchInput'),
        completedTaskList = document.getElementById('completedTaskList'),
        currentTaskActions = document.getElementById('currentTaskActions'),
        completionStats = document.getElementById('completionStats'),
        taskStatusHeader = document.getElementById('taskStatusHeader'),
        taskViewerBtn = document.getElementById('taskViewerBtn'),
        taskViewerModal = document.getElementById('taskViewerModal'),
        closeViewerBtn = document.getElementById('closeViewerBtn'),
        taskGrid = document.getElementById('taskGrid'),
        filterControls = document.getElementById('filterControls'),
        sortControls = document.getElementById('sortControls');

      // State variables
      let tasks = [],
        isSpinning = !1,
        lastWinner = null,
        audioContext = null,
        isSoundPlaying = !1,
        soundTimeoutId = null,
        taskViewerFilter = 'all',
        taskViewerSort = 'az';
      // Active default list for legacy fallbacks only (viewer uses all tiers; completion stats now use all tiers)
      let defaultTaskList = defaultEasyTasks;
      // Fixed target: start size equals easy list length. We maintain pool size at this target.
      let TARGET_POOL_SIZE = defaultEasyTasks.length;

      // Constants
      const ITEM_HEIGHT = 60,
        VISIBLE_ITEMS = 9,
        // Legacy keys (v1/v2) kept for migration
        TASKS_STORAGE_KEY_OLD = 'taskTickerTasks',
        TASKS_STORAGE_KEY = 'taskTickerTasks_v2',
        CURRENT_TASK_STORAGE_KEY_OLD = 'taskTickerCurrentTask_v2',
        // New keys (v3)
        TASKS_POOL_STORAGE_KEY = 'taskTickerPool_v1',
        CURRENT_TASK_STORAGE_KEY = 'taskTickerCurrentTask_v3',
        COMPLETED_STORAGE_KEY = 'taskTickerCompleted_v1';
      let virtualItems = [];

      // Quick lookups for defaults
      const easySet = new Set(defaultEasyTasks);
      const mediumSetConst = new Set(defaultMediumTasks);
      const hardSetConst = new Set(defaultHardTasks);
      const masterSetConst = new Set(defaultMasterTasks);
      const grandMasterSetConst = new Set(defaultGrandMasterTasks);

      const tierDefaults = {
        easy: defaultEasyTasks,
        medium: defaultMediumTasks,
        hard: defaultHardTasks,
        master: defaultMasterTasks,
        grandmaster: defaultGrandMasterTasks,
      };
      const tierSets = {
        easy: easySet,
        medium: mediumSetConst,
        hard: hardSetConst,
        master: masterSetConst,
        grandmaster: grandMasterSetConst,
      };
      const nextTierMap = {
        easy: 'medium',
        medium: 'hard',
        hard: 'master',
        master: 'grandmaster',
        grandmaster: null,
      };

      // Completed log (array of task texts); persisted
      let completedLog = [];
      function loadCompletedLog() {
        try {
          const raw = localStorage.getItem(COMPLETED_STORAGE_KEY);
          completedLog = raw ? JSON.parse(raw) : [];
          if (!Array.isArray(completedLog)) completedLog = [];
        } catch (e) {
          completedLog = [];
        }
      }
      function saveCompletedLog() {
        try {
          localStorage.setItem(COMPLETED_STORAGE_KEY, JSON.stringify(completedLog));
        } catch (e) {}
      }
      function addCompleted(text) {
        completedLog.push(text);
        saveCompletedLog();
      }
      function removeOneCompleted(text) {
        const i = completedLog.indexOf(text);
        if (i > -1) {
          completedLog.splice(i, 1);
          saveCompletedLog();
        }
      }

      // --- Sound Synthesis Functions ---
      function getAudioContext() {
        return (
          audioContext || (audioContext = new (window.AudioContext || window.webkitAudioContext)()),
          audioContext
        );
      }
      function createTickSound(e, t) {
        const o = e.createOscillator(),
          n = e.createGain();
        o.connect(n),
          n.connect(e.destination),
          (o.type = 'sine'),
          o.frequency.setValueAtTime(440, t),
          n.gain.setValueAtTime(0.01, t),
          n.gain.linearRampToValueAtTime(0.3, t + 0.005),
          n.gain.linearRampToValueAtTime(1e-4, t + 0.05),
          o.start(t),
          o.stop(t + 0.05);
      }
      function createFlourishSound(e, t) {
        const o = e.createOscillator(),
          n = e.createGain();
        o.connect(n),
          n.connect(e.destination),
          (o.type = 'sine'),
          o.frequency.setValueAtTime(880, t),
          o.frequency.linearRampToValueAtTime(1760, t + 0.2),
          n.gain.setValueAtTime(0.01, t),
          n.gain.linearRampToValueAtTime(0.5, t + 0.01),
          n.gain.linearRampToValueAtTime(1e-4, t + 0.8),
          o.start(t),
          o.stop(t + 0.8);
      }
      function createShuffleSound() {
        const e = getAudioContext(),
          t = 0.3,
          o = e.currentTime,
          n = e.createOscillator(),
          i = e.createGain();
        n.connect(i),
          i.connect(e.destination),
          (n.type = 'sine'),
          n.frequency.setValueAtTime(1e3, o),
          n.frequency.linearRampToValueAtTime(100, o + t),
          i.gain.setValueAtTime(0.5, o),
          i.gain.linearRampToValueAtTime(1e-4, o + t),
          n.start(o),
          n.stop(o + t);
      }
      function startSpinSound() {
        if (isSoundPlaying) return;
        isSoundPlaying = !0;
        const e = getAudioContext();
        soundTimeoutId && clearTimeout(soundTimeoutId);
        const t = parseFloat(spinDurationSlider.value),
          o = Math.min(10 + 0.2 * tasks.length, 40),
          n = 1,
          i = e.currentTime + 0.1;
        let a = i,
          s = 0;
        const l = setInterval(() => {
          if (s >= t) {
            clearInterval(l);
            createFlourishSound(e, a);
            soundTimeoutId = setTimeout(() => {
              isSoundPlaying = !1;
              soundTimeoutId = null;
              if (audioContext && audioContext.state === 'running') {
                try {
                  audioContext.close();
                } catch (err) {}
                audioContext = null;
              }
            }, 1e3 * (a - e.currentTime + 1));
            return;
          }
          createTickSound(e, a);
          const d = s / t;
          let r = o - (o - n) * d;
          r = Math.max(r, n);
          const c = 1 / Math.max(r, 0.1);
          a += c;
          s += c;
          if (a > i + t + 0.5) {
            clearInterval(l);
            createFlourishSound(e, i + t);
            soundTimeoutId = setTimeout(() => {
              isSoundPlaying = !1;
              soundTimeoutId = null;
              if (audioContext && audioContext.state === 'running') {
                try {
                  audioContext.close();
                } catch (err) {}
                audioContext = null;
              }
            }, 1e3 * (i + t - e.currentTime + 1));
          }
        }, 10);
      }
      function createSuccessChime() {
        const e = getAudioContext(),
          t = e.currentTime,
          o = e.createGain();
        o.gain.setValueAtTime(0.3, t), o.gain.exponentialRampToValueAtTime(1e-4, t + 1.2);
        const n = e.createOscillator();
        (n.type = 'sine'),
          n.frequency.setValueAtTime(523.25, t),
          n.frequency.setValueAtTime(659.25, t + 0.1);
        const i = e.createOscillator();
        (i.type = 'sine'),
          i.frequency.setValueAtTime(783.99, t + 0.2),
          n.connect(o),
          i.connect(o),
          o.connect(e.destination),
          n.start(t),
          n.stop(t + 0.2),
          i.start(t + 0.2),
          i.stop(t + 1);
      }

      // --- Configurable Confetti Effect ---
      function launchConfetti() {
        // --- Easy-to-change variables ---
        const CONFETTI_COUNT = 80;
        const CONFETTI_SIZE = '3.5rem';
        const CONFETTI_DURATION_MIN = 5000; // milliseconds
        const CONFETTI_DURATION_MAX = 9000; // milliseconds
        // ------------------------------------

        const emojis = ['üéâ', 'ü¶ä', 'üéä', 'üéà', 'ü¶ä', '‚≠ê'];
        for (let i = 0; i < CONFETTI_COUNT; i++) {
          const particle = document.createElement('div');
          particle.classList.add('confetti-particle');
          particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];

          const duration =
            Math.random() * (CONFETTI_DURATION_MAX - CONFETTI_DURATION_MIN) + CONFETTI_DURATION_MIN;

          particle.style.setProperty('--x-start', `${Math.random() * 100}vw`);
          particle.style.setProperty('--x-end', `${(Math.random() - 0.5) * 40}vw`);
          particle.style.setProperty('--size', CONFETTI_SIZE);
          particle.style.setProperty('--duration', `${duration}ms`);
          particle.style.setProperty('--delay', `${Math.random() * 0.5}s`);

          document.body.appendChild(particle);
          setTimeout(() => particle.remove(), duration + 500);
        }
      }

      // --- Core Application Logic ---
      const generateUniqueId = () => `_${Math.random().toString(36).substr(2, 9)}`;
      function shuffleTasks(e) {
        for (let t = e.length - 1; t > 0; t--) {
          const o = Math.floor(Math.random() * (t + 1));
          [e[t], e[o]] = [e[o], e[t]];
        }
      }
      function createVirtualItems() {
        (tickerReel.innerHTML = ''),
          (virtualItems = []),
          Array.from({ length: VISIBLE_ITEMS }).forEach(() => {
            const e = document.createElement('div');
            (e.className = 'ticker-item'), tickerReel.appendChild(e), virtualItems.push(e);
          });
      }
      function updateAndPositionItems(e) {
        if (0 === tasks.length) return void virtualItems.forEach((e) => (e.textContent = ''));
        const t = Math.round(e / ITEM_HEIGHT),
          o = Math.floor(VISIBLE_ITEMS / 2),
          n = t * ITEM_HEIGHT - e;
        virtualItems.forEach((i, a) => {
          const s = (t + a - o + 1e3 * tasks.length) % tasks.length,
            l = n + (a - o) * ITEM_HEIGHT + 2 * ITEM_HEIGHT;
          i.style.transform = `translateY(${l}px)`;
          const d = tasks[s]?.text || '';
          i.textContent !== d && (i.textContent = d);
        });
      }
      const easeOutCubic = (e) => --e * e * e + 1;
      function spin() {
        if (isSpinning || tasks.length < 1) return;
        (isSpinning = !0), (spinBtn.disabled = !0), startSpinSound();
        const e = Math.floor(Math.random() * tasks.length),
          t = tasks[e];
        if (!t) return (isSpinning = !1), void (spinBtn.disabled = !1);
        lastWinner = { id: t.id, text: t.text };
        const o = 15 + Math.floor(2 * Math.random()),
          n = o * tasks.length + e,
          i = n * ITEM_HEIGHT,
          a = 1e3 * parseFloat(spinDurationSlider.value);
        let s = null;
        const l = (d) => {
          s || (s = d);
          const r = Math.min((d - s) / a, 1),
            c = easeOutCubic(r),
            m = c * i;
          updateAndPositionItems(m),
            r < 1
              ? requestAnimationFrame(l)
              : ((isSpinning = !1), updateAndPositionItems(i), showWinnerModal(lastWinner.text));
        };
        requestAnimationFrame(l);
      }

      // --- Data & State Management ---

      // No settings: behavior is fully automatic.

      function loadData() {
        try {
          // Prefer new pool storage
          const poolRaw = localStorage.getItem(TASKS_POOL_STORAGE_KEY);
          const legacyRaw = localStorage.getItem(TASKS_STORAGE_KEY);
          const legacyRawV1 = localStorage.getItem(TASKS_STORAGE_KEY_OLD);
          const currentRawV3 = localStorage.getItem(CURRENT_TASK_STORAGE_KEY);
          const currentRawV2 = localStorage.getItem(CURRENT_TASK_STORAGE_KEY_OLD);

          if (poolRaw) {
            const parsed = JSON.parse(poolRaw);
            // Expect objects with {id,text,tier}
            if (Array.isArray(parsed) && parsed.length && parsed[0] && parsed[0].text) {
              tasks = parsed.map((t) => ({
                id: t.id || generateUniqueId(),
                text: t.text,
                tier:
                  t.tier === 'grandmaster'
                    ? 'grandmaster'
                    : t.tier === 'master'
                    ? 'master'
                    : t.tier === 'hard'
                    ? 'hard'
                    : t.tier === 'medium'
                    ? 'medium'
                    : t.tier === 'easy'
                    ? 'easy'
                    : 'custom',
              }));
              // Recompute target from initial default easy size if pool seems empty
              TARGET_POOL_SIZE = defaultEasyTasks.length || tasks.length;
            } else {
              tasks = defaultEasyTasks.map((text) => ({
                id: generateUniqueId(),
                text,
                tier: 'easy',
              }));
              TARGET_POOL_SIZE = defaultEasyTasks.length;
            }
          } else {
            // Fresh start: build pool from EASY defaults
            tasks = defaultEasyTasks.map((text) => ({
              id: generateUniqueId(),
              text,
              tier: 'easy',
            }));
            TARGET_POOL_SIZE = defaultEasyTasks.length;
            // Try to append legacy user-added tasks as custom
            let legacy = null;
            if (legacyRaw) legacy = JSON.parse(legacyRaw);
            else if (legacyRawV1) legacy = JSON.parse(legacyRawV1);
            if (Array.isArray(legacy) && legacy.length) {
              if (typeof legacy[0] === 'string') {
                legacy.forEach((text) =>
                  tasks.push({ id: generateUniqueId(), text, tier: 'custom' })
                );
              } else if (legacy[0] && legacy[0].text) {
                legacy.forEach((o) =>
                  tasks.push({ id: generateUniqueId(), text: o.text, tier: 'custom' })
                );
              }
            }
          }

          // Restore current task (v3 preferred)
          const currentRaw = currentRawV3 || currentRawV2;
          (currentRaw && displayCurrentTask(JSON.parse(currentRaw))) || updateCompletionStats();
        } catch (e) {
          console.error('Error loading data:', e),
            (tasks = defaultTaskList.map((e) => ({
              id: generateUniqueId(),
              text: e,
              tier: 'easy',
            })));
        }
      }
      function saveTasksToLocalStorage() {
        try {
          localStorage.setItem(TASKS_POOL_STORAGE_KEY, JSON.stringify(tasks));
        } catch (e) {
          console.error('Error saving tasks:', e);
        }
      }
      function saveCurrentTask(e) {
        try {
          e
            ? localStorage.setItem(CURRENT_TASK_STORAGE_KEY, JSON.stringify(e))
            : localStorage.removeItem(CURRENT_TASK_STORAGE_KEY);
        } catch (e) {
          console.error('Error saving current task:', e);
        }
      }
      const createTaskFrequencyMap = (e) => e.reduce((e, t) => ((e[t] = (e[t] || 0) + 1), e), {});
      // Helper: detect tier for a given task text
      function getTierOfText(text) {
        if (grandMasterSetConst.has(text)) return 'grandmaster';
        if (masterSetConst.has(text)) return 'master';
        if (hardSetConst.has(text)) return 'hard';
        if (mediumSetConst.has(text)) return 'medium';
        if (easySet.has(text)) return 'easy';
        return 'custom';
      }
      // Return UNIQUE completed default tasks (across ALL tiers)
      function getCompletedDefaultTasks() {
        const isDefault = (t) =>
          easySet.has(t) ||
          mediumSetConst.has(t) ||
          hardSetConst.has(t) ||
          masterSetConst.has(t) ||
          grandMasterSetConst.has(t);
        const completedSet = new Set(completedLog.filter(isDefault));
        return Array.from(completedSet);
      }
      function updateCompletedListUI() {
        const uniqueCompleted = getCompletedDefaultTasks(); // texts across all tiers
        completedTaskList.innerHTML = '';
        if (uniqueCompleted.length === 0) {
          completedTaskList.innerHTML =
            '<p class="text-center italic">No tasks completed from the default list yet.</p>';
          return;
        }
        uniqueCompleted
          .map((text) => ({ text, tier: getTierOfText(text) }))
          .sort((a, b) => a.text.localeCompare(b.text))
          .forEach(({ text, tier }) => {
            const row = document.createElement('div');
            row.className = 'flex items-center justify-between bg-gray-700/50 p-2 rounded-lg';
            const left = document.createElement('div');
            left.className = 'flex items-center gap-2 min-w-0';
            const badge = document.createElement('span');
            badge.className = 'text-xs px-2 py-0.5 rounded bg-gray-600 shrink-0';
            badge.textContent =
              tier === 'grandmaster'
                ? 'GM'
                : tier === 'master'
                ? 'Ma'
                : tier === 'hard'
                ? 'H'
                : tier === 'medium'
                ? 'M'
                : tier === 'easy'
                ? 'E'
                : 'C';
            const span = document.createElement('span');
            span.className = 'truncate pr-2';
            span.textContent = text;
            span.title = text;
            left.append(badge, span);
            const btn = document.createElement('button');
            btn.className =
              'text-xs bg-emerald-500 hover:bg-emerald-600 text-gray-900 font-bold px-3 py-1 rounded';
            btn.textContent = 'Restore';
            btn.title = 'Restore this task to active list';
            btn.addEventListener('click', () => restoreCompletedTask(text, tier));
            row.append(left, btn);
            completedTaskList.appendChild(row);
          });
      }

      function restoreCompletedTask(text, tier) {
        if (!text) return;
        const resolvedTier = tier || getTierOfText(text) || 'easy';
        tasks.push({ id: generateUniqueId(), text, tier: resolvedTier });
        // Remove one completion record for this task
        removeOneCompleted(text);
        // Keep pool size at target by removing a highest-tier item if oversized (prefer dropping above-easy)
        if (tasks.length > TARGET_POOL_SIZE) {
          const dropOrder = ['grandmaster', 'master', 'hard', 'medium'];
          for (const tier of dropOrder) {
            const idx = tasks.findIndex((t) => t.tier === tier);
            if (idx > -1) {
              tasks.splice(idx, 1);
              break;
            }
          }
        }
        updateTaskListUI();
        try {
          createShuffleSound();
        } catch {}
      }
      function updateCompletionStats() {
        // Count UNIQUE completed tasks across ALL default tiers
        const isDefault = (txt) =>
          easySet.has(txt) ||
          mediumSetConst.has(txt) ||
          hardSetConst.has(txt) ||
          masterSetConst.has(txt) ||
          grandMasterSetConst.has(txt);
        const filteredCompleted = completedLog.filter(isDefault);
        const completedUniqueAll = new Set(filteredCompleted).size;
        const totalDefaults =
          (defaultEasyTasks?.length || 0) +
          (defaultMediumTasks?.length || 0) +
          (defaultHardTasks?.length || 0) +
          (defaultMasterTasks?.length || 0) +
          (defaultGrandMasterTasks?.length || 0);
        const percent =
          totalDefaults > 0 ? ((completedUniqueAll * 100) / totalDefaults).toFixed(1) : 0;
        const nextIndex = filteredCompleted.length + 1;
        completionStats.textContent = `Task #${nextIndex} | ${percent}% Complete`;
      }
      function countPoolByTier() {
        let easy = 0,
          medium = 0,
          hard = 0,
          master = 0,
          grandmaster = 0,
          custom = 0;
        for (const t of tasks) {
          if (t.tier === 'easy') easy++;
          else if (t.tier === 'medium') medium++;
          else if (t.tier === 'hard') hard++;
          else if (t.tier === 'master') master++;
          else if (t.tier === 'grandmaster') grandmaster++;
          else custom++;
        }
        return { easy, medium, hard, master, grandmaster, custom, total: tasks.length };
      }
      function updateRollOddsUI() {
        const infoEl = document.getElementById('rollOddsInfo');
        if (!infoEl) return;
        const { easy, medium, hard, master, grandmaster, custom, total } = countPoolByTier();
        const easyCount = easy + custom;
        const pct = (n) => (total ? Math.round((n / total) * 100) : 0);
        infoEl.innerHTML = `Pool: <span class="font-semibold">${total}</span>
          &nbsp; ¬∑ &nbsp; <span class="text-emerald-300">Easy ${easyCount} (${pct(
          easyCount
        )}%)</span>
          &nbsp; ¬∑ &nbsp; <span class="text-orange-300">Medium ${medium} (${pct(medium)}%)</span>
          &nbsp; ¬∑ &nbsp; <span class="text-yellow-300">Hard ${hard} (${pct(hard)}%)</span>
          &nbsp; ¬∑ &nbsp; <span class="text-purple-300">Master ${master} (${pct(master)}%)</span>
          &nbsp; ¬∑ &nbsp; <span class="text-pink-300">Grand-Master ${grandmaster} (${pct(
          grandmaster
        )}%)</span>`;
      }
      const updateTaskListUI = () => {
          const e = searchInput.value.toLowerCase(),
            t = tasks.filter((t) => t.text.toLowerCase().includes(e)),
            o = !!localStorage.getItem(CURRENT_TASK_STORAGE_KEY);
          (taskList.innerHTML = ''),
            0 === t.length
              ? (taskList.innerHTML = `<p class="text-gray-400 text-center">${
                  e ? 'No tasks match your search.' : 'Add tasks to spin!'
                }</p>`)
              : t.forEach((e) => {
                  const t = document.createElement('div');
                  (t.className =
                    'task-item flex items-center justify-between bg-gray-700 p-2 rounded-lg'),
                    (t.innerHTML = `<span class="flex-grow truncate pr-2">${
                      e.text
                    }</span><span class="text-xs px-2 py-0.5 rounded bg-gray-600 mr-2">${
                      e.tier === 'grandmaster'
                        ? 'GM'
                        : e.tier === 'master'
                        ? 'Ma'
                        : e.tier === 'hard'
                        ? 'H'
                        : e.tier === 'medium'
                        ? 'M'
                        : e.tier === 'easy'
                        ? 'E'
                        : 'C'
                    }</span><button title="Remove task" class="remove-btn text-red-400 hover:text-red-600 font-bold">‚úñ</button>`),
                    (t.querySelector('.remove-btn').onclick = () => removeTask(e.id)),
                    taskList.appendChild(t);
                }),
            (spinBtn.disabled = tasks.length < 1 || o),
            (shuffleBtn.disabled = o || tasks.length < 2),
            (sortBtn.disabled = o || tasks.length < 2),
            updateAndPositionItems(0),
            saveTasksToLocalStorage(),
            updateCompletedListUI(),
            updateCompletionStats(),
            updateRollOddsUI();
        },
        handleAddTask = () => {
          const e = taskInput.value.trim();
          e &&
            (tasks.push({ id: generateUniqueId(), text: e, tier: 'custom' }),
            (taskInput.value = ''),
            updateTaskListUI());
        },
        removeTask = (e) => {
          const t = tasks.findIndex((t) => t.id === e);
          t > -1 && (tasks.splice(t, 1), updateTaskListUI());
        };

      // --- UI Interaction Handlers ---
      function showWinnerModal(e) {
        (winnerText.textContent = e || 'Nothing!'),
          winnerModal.classList.remove('opacity-0', 'pointer-events-none'),
          modalContent.classList.remove('scale-95');
      }
      function hideWinnerModal() {
        winnerModal.classList.add('opacity-0', 'pointer-events-none'),
          modalContent.classList.add('scale-95');
      }
      function handleModalOkay() {
        hideWinnerModal(), saveCurrentTask(lastWinner), displayCurrentTask(lastWinner);
      }
      function displayCurrentTask(e) {
        e &&
          (updateCompletionStats(),
          (taskStatusHeader.textContent = 'Current Task'),
          (currentTaskText.textContent = e.text),
          currentTaskActions.classList.remove('hidden'),
          currentTaskContainer.classList.remove('hidden'),
          (spinBtn.disabled = !0),
          (shuffleBtn.disabled = !0),
          (sortBtn.disabled = !0));
      }
      function showPostCompletionMessage() {
        (taskStatusHeader.textContent = 'Task Complete!'),
          (currentTaskText.textContent = 'Roll your next task'),
          currentTaskActions.classList.add('hidden'),
          currentTaskContainer.classList.remove('hidden');
        const e = !1;
        (spinBtn.disabled = tasks.length < 1 || e),
          (shuffleBtn.disabled = e || tasks.length < 2),
          (sortBtn.disabled = e || tasks.length < 2);
      }
      function handleCompleteCurrentTask() {
        createSuccessChime(), launchConfetti();
        const raw = localStorage.getItem(CURRENT_TASK_STORAGE_KEY);
        if (raw) {
          const cur = JSON.parse(raw);
          // Identify the task in pool BEFORE removal to know its tier
          const poolTask = tasks.find((t) => t.id === cur.id) || null;
          // Log completion if it belongs to our defaults
          if (
            poolTask &&
            (easySet.has(poolTask.text) ||
              mediumSetConst.has(poolTask.text) ||
              hardSetConst.has(poolTask.text) ||
              masterSetConst.has(poolTask.text) ||
              grandMasterSetConst.has(poolTask.text))
          ) {
            addCompleted(poolTask.text);
          }
          // Remove from pool
          removeTask(cur.id);
          // Replacement cascade: add one task from the next tier if available
          if (poolTask) {
            const next = nextTierMap[poolTask.tier];
            if (next) addRandomFromTier(next, 1);
          }
          // Maintain pool size by topping up from the highest available tier in order
          checkAndMaybeDumpTiers();
          const { total } = countPoolByTier();
          if (total < TARGET_POOL_SIZE) {
            const order = ['medium', 'hard', 'master', 'grandmaster'];
            for (const tier of order) {
              const needed = Math.max(0, TARGET_POOL_SIZE - tasks.length);
              if (needed <= 0) break;
              addRandomFromTier(tier, needed);
            }
          }
        }
        saveCurrentTask(null), showPostCompletionMessage();
      }
      function handleSkipCurrentTask() {
        saveCurrentTask(null), showPostCompletionMessage();
      }
      function toggleManagePanel() {
        const e = manageTasksPanel.classList.contains('hidden');
        e
          ? (manageTasksPanel.classList.remove('hidden'),
            appContainer.classList.remove('justify-center'),
            appContainer.classList.add('lg:justify-between'),
            // when panel is visible, constrain overall width to original max
            appContainer.classList.remove('max-w-[80vw]'),
            appContainer.classList.add('max-w-6xl'),
            spinnerContainer.classList.remove('lg:w-full'),
            spinnerContainer.classList.add('lg:w-1/2'),
            updateRollOddsUI())
          : (manageTasksPanel.classList.add('hidden'),
            appContainer.classList.remove('lg:justify-between'),
            appContainer.classList.add('justify-center'),
            // when panel is hidden, allow spinner to grow to 80vw
            appContainer.classList.remove('max-w-6xl'),
            appContainer.classList.add('max-w-[80vw]'),
            spinnerContainer.classList.remove('lg:w-1/2'),
            spinnerContainer.classList.add('lg:w-full'));
      }

      function addRandomFromTier(tier, count) {
        if (!tier || count <= 0) return;
        const defaults = tierDefaults[tier] || [];
        const set = tierSets[tier];
        if (!defaults || defaults.length === 0) return;
        const inPool = new Set(tasks.filter((t) => t.tier === tier).map((t) => t.text));
        const completedForTier = new Set(completedLog.filter((t) => set && set.has(t)));
        const candidates = defaults.filter((t) => !inPool.has(t) && !completedForTier.has(t));
        if (candidates.length === 0) return;
        const toAdd = Math.min(count, candidates.length);
        for (let i = 0; i < toAdd; i++) {
          const idx = Math.floor(Math.random() * candidates.length);
          const text = candidates.splice(idx, 1)[0];
          tasks.push({ id: generateUniqueId(), text, tier });
        }
        updateTaskListUI();
      }

      // Dump all remaining tasks from a tier into the pool (excluding ones already in pool or completed)
      function dumpTierIntoPool(tier) {
        const defaults = tierDefaults[tier] || [];
        const set = tierSets[tier];
        if (!defaults || defaults.length === 0) return 0;
        const inPool = new Set(tasks.filter((t) => t.tier === tier).map((t) => t.text));
        const completedForTier = new Set(completedLog.filter((t) => set && set.has(t)));
        const candidates = defaults.filter((t) => !inPool.has(t) && !completedForTier.has(t));
        for (const text of candidates) {
          tasks.push({ id: generateUniqueId(), text, tier });
        }
        if (candidates.length) updateTaskListUI();
        return candidates.length;
      }

      // If remaining in a tier (by completions only) drops to 20% or less, dump next tier and expand target
      function checkAndMaybeDumpTiers() {
        const chain = ['easy', 'medium', 'hard', 'master'];
        for (const tier of chain) {
          const next = nextTierMap[tier];
          if (!next) continue;
          const totalDefaults = tierDefaults[tier]?.length || 0;
          if (totalDefaults === 0) continue;
          // Compute based ONLY on completed list (ignore in-pool and not-yet-pulled)
          const completedUniqueCount = new Set(
            completedLog.filter((t) => tierSets[tier] && tierSets[tier].has(t))
          ).size;
          const remainingByCompletion = totalDefaults - completedUniqueCount;
          const threshold = Math.ceil(totalDefaults * 0.2);
          if (remainingByCompletion <= threshold) {
            // Dump next tier fully and expand TARGET_POOL_SIZE to current tasks length
            dumpTierIntoPool(next);
            TARGET_POOL_SIZE = tasks.length;
          }
        }
      }

      // --- Task Viewer Functions ---
      function renderTaskViewerGrid() {
        const fullDefaultList = defaultEasyTasks
          .concat(defaultMediumTasks)
          .concat(defaultHardTasks)
          .concat(defaultMasterTasks)
          .concat(defaultGrandMasterTasks);
        const completedMap = createTaskFrequencyMap(completedLog);
        const used = {};

        let allTaskItems = fullDefaultList.map((taskText) => {
          const usedCount = used[taskText] || 0;
          const isCompleted = usedCount < (completedMap[taskText] || 0);
          if (isCompleted) used[taskText] = usedCount + 1;
          return { text: taskText, completed: isCompleted };
        });

        // Filter
        if (taskViewerFilter === 'completed') {
          allTaskItems = allTaskItems.filter((task) => task.completed);
        } else if (taskViewerFilter === 'incomplete') {
          allTaskItems = allTaskItems.filter((task) => !task.completed);
        }

        // Sort
        if (taskViewerSort === 'az') {
          allTaskItems.sort((a, b) => a.text.localeCompare(b.text));
        } else if (taskViewerSort === 'random') {
          shuffleTasks(allTaskItems);
        }

        const totalItems = allTaskItems.length;
        taskGrid.innerHTML = '';
        if (totalItems === 0) {
          taskGrid.innerHTML = `<p class="col-span-full text-center text-gray-400 text-2xl">No tasks match the current filter.</p>`;
          taskGrid.style.gridTemplateColumns = '1fr';
          taskGrid.style.gridTemplateRows = '1fr';
          return;
        }

        const containerWidth = taskGrid.clientWidth;
        const containerHeight = taskGrid.clientHeight;
        const aspectRatio = containerWidth / containerHeight;
        const idealCols = Math.sqrt(totalItems * aspectRatio);
        const cols = Math.ceil(idealCols);
        const rows = Math.ceil(totalItems / cols);

        taskGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        taskGrid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

        const itemsToRender = allTaskItems.map((task) => {
          const div = document.createElement('div');
          div.className = `task-grid-item ${task.completed ? 'completed' : ''}`;
          div.textContent = task.text;
          return div;
        });
        taskGrid.append(...itemsToRender);
      }

      function updateViewerControlsUI() {
        document.querySelectorAll('#filterControls .viewer-btn').forEach((btn) => {
          btn.classList.toggle('active', btn.dataset.filter === taskViewerFilter);
        });
        document.querySelectorAll('#sortControls .viewer-btn').forEach((btn) => {
          btn.classList.toggle('active', btn.dataset.sort === taskViewerSort);
        });
      }

      function openTaskViewer() {
        updateViewerControlsUI();
        renderTaskViewerGrid();
        taskViewerModal.classList.remove('opacity-0', 'pointer-events-none');
      }
      function closeTaskViewer() {
        taskViewerModal.classList.add('opacity-0', 'pointer-events-none');
      }

      // --- Reset All ---
      function showResetModal() {
        const modal = document.getElementById('resetConfirmModal');
        modal.classList.remove('opacity-0', 'pointer-events-none');
        modal.querySelector('.modal-content').classList.remove('scale-95');
      }
      function hideResetModal() {
        const modal = document.getElementById('resetConfirmModal');
        modal.classList.add('opacity-0', 'pointer-events-none');
        modal.querySelector('.modal-content').classList.add('scale-95');
      }
      function performFullReset() {
        try {
          // Clear persisted data
          localStorage.removeItem(TASKS_POOL_STORAGE_KEY);
          localStorage.removeItem(CURRENT_TASK_STORAGE_KEY);
          localStorage.removeItem(TASKS_STORAGE_KEY);
          localStorage.removeItem(TASKS_STORAGE_KEY_OLD);
          localStorage.removeItem(CURRENT_TASK_STORAGE_KEY_OLD);
          localStorage.removeItem(COMPLETED_STORAGE_KEY);
        } catch {}

        // Reset in-memory state
        completedLog = [];
        tasks = defaultEasyTasks.map((text) => ({ id: generateUniqueId(), text, tier: 'easy' }));
        TARGET_POOL_SIZE = defaultEasyTasks.length;
        lastWinner = null;
        saveCurrentTask(null);
        saveTasksToLocalStorage();
        updateTaskListUI();
        updateViewerControlsUI();
        updateRollOddsUI();
      }

      // --- Event Listeners ---
      spinBtn.addEventListener('click', spin);
      addTaskBtn.addEventListener('click', handleAddTask);
      taskInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') handleAddTask();
      });
      shuffleBtn.addEventListener('click', () => {
        tasks.length > 1 && (shuffleTasks(tasks), updateTaskListUI(), createShuffleSound());
      });
      sortBtn.addEventListener('click', () => {
        tasks.length > 1 &&
          (tasks.sort((e, t) => e.text.localeCompare(t.text)),
          updateTaskListUI(),
          createShuffleSound());
      });
      spinDurationSlider.addEventListener('input', () => {
        spinDurationValue.textContent = spinDurationSlider.value;
      });
      modalOkayBtn.addEventListener('click', handleModalOkay);
      currentTaskCompleteBtn.addEventListener('click', handleCompleteCurrentTask);
      currentTaskSkipBtn.addEventListener('click', handleSkipCurrentTask);
      toggleManageBtn.addEventListener('click', toggleManagePanel);
      searchInput.addEventListener('input', updateTaskListUI);
      taskViewerBtn.addEventListener('click', openTaskViewer);
      closeViewerBtn.addEventListener('click', closeTaskViewer);
      taskViewerModal.addEventListener('click', (e) => {
        e.target === taskViewerModal && closeTaskViewer();
      });
      // Reset button and modal events
      const resetAllBtn = document.getElementById('resetAllBtn');
      const resetConfirmModal = document.getElementById('resetConfirmModal');
      const resetConfirmYesBtn = document.getElementById('resetConfirmYesBtn');
      const resetConfirmNoBtn = document.getElementById('resetConfirmNoBtn');
      if (resetAllBtn) {
        resetAllBtn.addEventListener('click', showResetModal);
      }
      if (resetConfirmNoBtn) {
        resetConfirmNoBtn.addEventListener('click', hideResetModal);
      }
      if (resetConfirmYesBtn) {
        resetConfirmYesBtn.addEventListener('click', () => {
          performFullReset();
          hideResetModal();
        });
      }
      // Close reset modal when clicking outside
      if (resetConfirmModal) {
        resetConfirmModal.addEventListener('click', (e) => {
          if (e.target === resetConfirmModal) hideResetModal();
        });
      }
      window.addEventListener('resize', () => {
        !taskViewerModal.classList.contains('opacity-0') && renderTaskViewerGrid();
      });

      // No settings to wire up anymore.

      filterControls.addEventListener('click', (e) => {
        if (e.target.matches('.viewer-btn')) {
          taskViewerFilter = e.target.dataset.filter;
          updateViewerControlsUI();
          renderTaskViewerGrid();
        }
      });

      sortControls.addEventListener('click', (e) => {
        if (e.target.matches('.viewer-btn')) {
          taskViewerSort = e.target.dataset.sort;
          updateViewerControlsUI();
          renderTaskViewerGrid();
        }
      });

      // --- Initialization ---
      window.onload = () => {
        loadCompletedLog();
        loadData();
        createVirtualItems();
        updateTaskListUI();
        updateViewerControlsUI(); // Set initial active buttons
        updateRollOddsUI();
      };
    </script>
  </body>
</html>
